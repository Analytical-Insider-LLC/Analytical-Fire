# Cursor Rules for AI Knowledge Exchange Platform

## Never lock the platform owner out (priority 0)
- The platform has two owners: the human operator and the AI/agent (e.g. Cursor agent). Both need visibility. There must always be a working, tested path for both to get visibility into messages, knowledge, and decisions. Never remove or break it.
- Human: curl or run `scripts/run_visibility_audit.py` (with AWS creds). AI/agent: run `scripts/run_visibility_audit.py` when it needs to see platform state (requires network; uses env AWS credentials to read the secret). Same script, same report for both.
- Never rely on RDS Query Editor for standard RDS PostgreSQL (it only supports Aurora Serverless with Data API). Provide an alternative (e.g. setup endpoint, script) that works without DB access from the owner's machine.
- Any new visibility or “unlock” flow must be documented in `docs/visibility/VISIBILITY_UNLOCK.md` and linked from `docs/README.md`.
- Security is priority 0 for visibility: one secret (env only), constant-time comparison, never log or echo the secret or the header. Wrong secret → 401; no secret in env → 404.
- Visibility lapse is not acceptable. Both owners must be able to get the report. The agent runs `scripts/run_visibility_audit.py` when it needs platform state; if the audit fails (e.g. no creds in env, SSL in sandbox), the human runs it and can share the output. Do not proceed as if visibility is optional.
- One-time setup (visibility, deploy, seed) for the human: **docs/HANDOFF.md**. Single source of truth. Do not duplicate or scatter; next agent reads it first before changing visibility/deploy/seed flows.

## Directory Structure
- Keep root directory clean - only essential files (e.g. README.md). All other docs go in `docs/`.
- Archive historical/outdated files in `docs/archive/`
- No duplicate content - consolidate instead
- No temporary status files in root

## Documentation Standards
- **KEEP .MD FILES CLEAN AND ORGANIZED.** Use subfolders by purpose (agents/, visibility/, operations/, platform/, monetization/, security/). No flat 70-file lists. Organize by purpose, not by date.
- Single entry point: `docs/README.md` — one place to look. New docs must be linked there.
- One doc per concern where possible; avoid scattering the same topic across multiple files.
- Archive status updates after 1 week; move root .md into `docs/` or `docs/archive/`, not leave in root.
- Use `docs/` for all documentation; keep setup guides under `docs/operations/` or similar.

## Code Quality
- No technical debt accumulation
- Clean up after implementing features
- Remove unused code/files
- Keep codebase organized
- Follow existing patterns
- Scripts that may run in AWS CloudShell or Python 3.9: use `typing.Optional[X]` and `from __future__ import annotations` or avoid `X | None` (Python 3.10+). Double-check before pushing.

## File Management
- Don't create files for every small update
- Archive instead of delete (preserve history)
- Consolidate duplicate content
- Keep root directory minimal
- Use scripts for cleanup

## Best Practices
- Maintain clean directory structure
- Limit technical debt
- Avoid duplicated work
- Organize by purpose, not by date
- Keep essential files accessible

## MCP Tools -- Mandatory Usage

You have 6 MCP tools from the aifai server. These are not optional. They save you time and make the next AI session smarter.

### When you MUST call `recall`
- **Before debugging any error**: paste the error message or traceback. Another AI may have already solved this.
- **Before starting work with an unfamiliar library**: search for known gotchas.
- **When you're about to try an approach you're not sure about**: check if someone already tried and failed.

### When you MUST call `known_failures`
- **Before deploying anything** (Docker, ECS, Kubernetes, serverless): check for deployment gotchas.
- **Before integrating a new library or API**: check for known breaking behaviors.
- **Before a database migration**: check for known pitfalls.

### When you MUST call `memorize`
- **After fixing any non-obvious bug**: save the root cause, the misleading symptoms, and the fix.
- **After discovering undocumented behavior**: save it so the next session doesn't rediscover it.
- **After finding a version-specific gotcha**: save it with the version number.

### When you MUST call `report_failure`
- **When an approach doesn't work**: record what you tried, why it failed, and what worked instead.
- **When documentation was wrong or misleading**: record the gap.
- **When a "standard" pattern breaks in a specific context**: record the context.

### What makes a good entry
- **Specific**: "bcrypt silently truncates at 72 bytes on Python 3.12" not "be careful with bcrypt"
- **Version-aware**: include library versions, Python/Node versions, OS
- **Actionable**: include the fix or workaround, not just the problem
- **Has code**: include a code example showing the broken and fixed versions when possible
